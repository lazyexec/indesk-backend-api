// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// TODO: Change Phone Number to String

generator client {
  provider = "prisma-client-js"
  // output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  provider
  user
}

enum ClinicRole {
  clinician
  admin
  superAdmin
}

enum AppointmentStatus {
  pending
  completed
  cancelled
  scheduled
}

enum MeetingType {
  in_person
  zoom
  google_meet
}

enum Gender {
  male
  female
  other
}

enum ClientStatus {
  active
  pending
  inactive
}

enum IntegrationType {
  google_calendar
  google_meet
  stripe
  mailchimp
  zoom
  twilio
}

enum IntegrationStatus {
  connected
  disconnected
}

enum QuestionType {
  text
  multiple_choice
  yes_no
}

enum AssessmentCategory {
  general_clinical
  mental_health
  physical_therapy
  neurology
}

enum AssessmentStatus {
  pending
  in_progress
  completed
}

enum InvoiceStatus {
  pending
  paid
  overdue
}

enum PlanType {
  free
  professional
  enterprise
}

enum SubscriptionStatus {
  active
  inactive
  cancelled
  past_due
  trialing
}

model User {
  id                         String               @id @default(uuid())
  email                      String               @unique
  firstName                  String?
  lastName                   String?
  avatar                     String?              @default("/uploads/users/user.png")
  password                   String?
  role                       Role                 @default(user)
  oneTimeCode                String?
  oneTimeCodeExpires         DateTime?
  isEmailVerified            Boolean              @default(false)
  isResetPassword            Boolean              @default(false)
  isDeleted                  Boolean              @default(false)
  fcmToken                   String?
  phoneNumber                String?
  countryCode                String?
  // Status
  isRestricted               Boolean              @default(false)
  restrictionReason          String?
  // Business
  bio                        String?
  // Timestamps
  isOnline                   Boolean              @default(false)
  lastSeen                   DateTime?
  lastLoginAt                DateTime?            @default(now())
  lastPasswordChangedAt      DateTime?
  createdAt                  DateTime             @default(now())
  updatedAt                  DateTime             @updatedAt
  // Relations
  tokens                     Token[]
  ownedClinics               Clinic[]             @relation("ClinicOwner")
  clinicMemberships          ClinicMember[]
  notes                      ClinicalNote[]
  assessments                AssessmentInstance[]
  createdAssessmentTemplates AssessmentTemplate[]
  clients                    Client[]
  reportedIssues             UserIssue[]
  adminResponses             UserIssue[]          @relation("AdminResponse")
  transactions               Transaction[]
  notifications              Notification[]
}

model Token {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  type      String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
}

model Clinic {
  id          String  @id @default(uuid())
  name        String
  email       String? @unique
  phoneNumber String?
  countryCode String?
  address     Json?
  logo        String?
  color       String?
  description String?
  permissions Json    @default("{}")
  publicToken String? @unique // Token for public clinic access

  // Activation status for purchase flow
  isActive    Boolean   @default(false)
  activatedAt DateTime?

  ownerId      String         @unique
  owner        User           @relation("ClinicOwner", fields: [ownerId], references: [id])
  // Relations
  members      ClinicMember[]
  clients      Client[]
  appointments Appointment[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  sessions     Session[]
  invoices     Invoice[]

  integrations        Integration[]
  assessmentTemplates AssessmentTemplate[]
  subscription        Subscription?
  issues              UserIssue[]
  transactions        Transaction[]

  @@index([ownerId])
  @@index([publicToken])
}

model Integration {
  id           String            @id @default(uuid())
  clinicId     String
  clinic       Clinic            @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  type         IntegrationType
  status       IntegrationStatus @default(disconnected)
  config       Json? // Stores credentials, IDs, tokens, etc.
  isConfigured Boolean           @default(false)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@unique([clinicId, type])
  @@index([clinicId])
}

model ClinicMember {
  id                  String               @id @default(uuid())
  userId              String
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinicId            String
  clinic              Clinic               @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  role                ClinicRole           @default(clinician)
  clinicianToken      String?              @unique @default(uuid())
  availability        String[]             @default([])
  specialization      String[]             @default([])
  assignedClients     Client[]             @relation("AssignedClinician")
  notes               ClinicalNote[]
  assessmentInstances AssessmentInstance[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  appointments      Appointment[] @relation("AppointmentClinician")
  addedAppointments Appointment[] @relation("AppointmentAddedBy")
  addedClients      Client[]      @relation("ClientAddedBy")
  clients           Client[]

  @@unique([userId, clinicId])
  @@index([clinicId])
  @@index([userId])
}

model Client {
  id String @id @default(uuid())

  firstName   String
  lastName    String
  email       String
  dateOfBirth DateTime?
  gender      Gender    @default(male)
  phoneNumber String?
  countryCode String?
  address     Json?

  // Insurance
  insuranceProvider            String?
  insuranceNumber              String?
  insuranceAuthorizationNumber String?

  // Notes
  note String?

  // Status
  status ClientStatus @default(active)

  // Assigned clinician (optional)
  assignedClinicianId String?
  assignedClinician   ClinicMember? @relation(name: "AssignedClinician", fields: [assignedClinicianId], references: [id])

  // Belongs to clinic
  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Added by
  addedBy     String
  addedByUser ClinicMember @relation("ClientAddedBy", fields: [addedBy], references: [id], onDelete: Cascade)

  // Relations
  appointments        Appointment[]
  notes               ClinicalNote[]
  assessmentInstances AssessmentInstance[]
  transactions        Transaction[]
  invoices            Invoice[]

  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  user           User?         @relation(fields: [userId], references: [id])
  userId         String?
  clinicMember   ClinicMember? @relation(fields: [clinicMemberId], references: [id])
  clinicMemberId String?

  @@index([clinicId])
  @@index([email])
}

model Session {
  id       String @id @default(uuid())
  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  name     String

  duration             Int // in minutes
  description          String?
  price                Float
  color                String?
  reminders            Json?         @default("[120, 60]") // e.g., [120, 60] minutes before (2hr, 1hr)
  reminderMethod       String?       @default("notification") // "notification", "sms", "email", "all"
  enableSmsReminders   Boolean       @default(false)
  enableEmailReminders Boolean       @default(false)
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  appointments         Appointment[]
  transactions         Transaction[]

  @@index([clinicId])
}

model Appointment {
  id                    String            @id @default(uuid())
  clinicId              String
  clinicianId           String
  addedBy               String
  clientId              String
  sessionId             String
  status                AppointmentStatus @default(pending)
  startTime             DateTime
  endTime               DateTime
  note                  String?
  meetingType           MeetingType       @default(zoom)
  zoomJoinUrl           String?
  zoomStartUrl          String?
  zoomMeetingId         String?
  googleMeetUrl         String?
  googleMeetId          String?
  googleCalendarEventId String?
  appointmentToken      String?           @unique
  transactionId         String?
  invoiceId             String?
  via                   String?           @default("admin")

  // Relations
  transaction Transaction? @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  clinician   ClinicMember @relation("AppointmentClinician", fields: [clinicianId], references: [id], onDelete: Restrict)
  addedByUser ClinicMember @relation("AppointmentAddedBy", fields: [addedBy], references: [id], onDelete: Restrict)
  session     Session      @relation(fields: [sessionId], references: [id], onDelete: Restrict)
  clinic      Clinic       @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  client      Client       @relation(fields: [clientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Remove these lines:
  // userId         String?
  // clinicMemberId String?

  @@index([clinicId])
  @@index([clinicianId])
  @@index([addedBy])
  @@index([clientId])
  @@index([startTime])
  @@index([appointmentToken])
}

model ClinicalNote {
  id       String       @id @default(uuid())
  clientId String
  client   Client       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  authorId String
  author   ClinicMember @relation(fields: [authorId], references: [id], onDelete: Restrict)

  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?

  @@index([clientId])
  @@index([authorId])
}

model AssessmentTemplate {
  id            String               @id @default(uuid())
  clinicId      String
  clinic        Clinic               @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  createdBy     String
  createdByUser User                 @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  title         String
  description   String?
  category      AssessmentCategory   @default(general_clinical)
  document      String? // Optional document URL/path
  note          String? // Optional note/instructions
  isActive      Boolean              @default(true)
  questions     AssessmentQuestion[]
  instances     AssessmentInstance[]
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@index([clinicId])
  @@index([createdBy])
  @@index([category])
}

model AssessmentQuestion {
  id            String               @id @default(uuid())
  templateId    String
  template      AssessmentTemplate   @relation(fields: [templateId], references: [id], onDelete: Cascade)
  question      String
  type          QuestionType
  options       Json? // For MCQ: ["option1", "option2", ...]
  correctAnswer String? // For MCQ: the correct option
  points        Int                  @default(1) // Points for correct answer
  order         Int                  @default(0) // Order of question in template
  responses     AssessmentResponse[]
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  @@index([templateId])
}

model AssessmentInstance {
  id             String               @id @default(uuid())
  templateId     String
  template       AssessmentTemplate   @relation(fields: [templateId], references: [id], onDelete: Restrict)
  clientId       String
  client         Client               @relation(fields: [clientId], references: [id], onDelete: Cascade)
  clinicianId    String?
  clinician      ClinicMember?        @relation(fields: [clinicianId], references: [id], onDelete: SetNull)
  assignedBy     String
  assignedByUser User                 @relation(fields: [assignedBy], references: [id], onDelete: Restrict)
  status         AssessmentStatus     @default(pending)
  shareToken     String               @unique // Token for email sharing
  document       String? // Optional document URL/path
  note           String? // Optional note/instructions
  score          Float? // Calculated score
  maxScore       Float? // Maximum possible score
  completedAt    DateTime?
  responses      AssessmentResponse[]
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt

  @@index([templateId])
  @@index([clientId])
  @@index([clinicianId])
  @@index([assignedBy])
  @@index([shareToken])
}

model AssessmentResponse {
  id         String             @id @default(uuid())
  instanceId String
  instance   AssessmentInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  questionId String
  question   AssessmentQuestion @relation(fields: [questionId], references: [id], onDelete: Restrict)
  answer     String // Text answer or selected MCQ option
  isCorrect  Boolean? // For MCQ: whether answer is correct
  points     Float? // Points earned for this answer
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  @@unique([instanceId, questionId])
  @@index([instanceId])
  @@index([questionId])
}

model Transaction {
  id            String   @id @default(uuid())
  sessionId     String? // Optional for clinic purchases
  clientId      String? // Optional for clinic purchases
  clinicId      String? // For clinic purchase transactions
  userId        String? // User who made the transaction
  transactionId String?  @unique
  amount        Float?
  type          String? // "appointment", "clinic_purchase", "subscription", etc.
  method        String? // "stripe", "cash", etc.
  status        String? // "pending", "completed", "failed", "refunded"
  description   String?
  meta          Json? // Store additional data like planId, stripeSessionId, etc.
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  client      Client?       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  session     Session?      @relation(fields: [sessionId], references: [id], onDelete: Restrict)
  clinic      Clinic?       @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  user        User?         @relation(fields: [userId], references: [id], onDelete: Restrict)
  appointment Appointment[]

  @@index([sessionId])
  @@index([clientId])
  @@index([clinicId])
  @@index([userId])
  @@index([type])
  @@index([status])
}

model Invoice {
  id       String @id @default(uuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Restrict)
  clinicId String
  clinic   Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // New item-based invoice fields
  items       Json // Store invoice items as JSON
  subtotal    Float
  tax         Float
  totalAmount Float

  status      InvoiceStatus @default(pending)
  invoiceDate DateTime // Renamed from issueDate for consistency
  dueDate     DateTime
  publicToken String?       @unique // Token for public invoice access

  // Keep appointments relation for backward compatibility
  appointments Appointment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clientId])
  @@index([clinicId])
  @@index([publicToken])
}

model Plan {
  id             String   @id @default(uuid())
  name           String   @unique
  type           PlanType @unique
  description    String?
  price          Float    @default(0)
  clientLimit    Int      @default(0) // 0 means unlimited
  clinicianLimit Int      @default(0) // 0 means unlimited
  features       Json     @default("{}") // JSON object with feature flags
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  subscriptions Subscription[]

  @@index([type])
}

model Subscription {
  id                   String             @id @default(uuid())
  clinicId             String             @unique
  clinic               Clinic             @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  planId               String
  plan                 Plan               @relation(fields: [planId], references: [id], onDelete: Restrict)
  status               SubscriptionStatus @default(active)
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  trialStart           DateTime?
  trialEnd             DateTime?
  cancelledAt          DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  @@index([clinicId])
  @@index([planId])
  @@index([status])
}

enum IssueType {
  bug
  feature_request
  technical_issue
  billing_issue
  general_feedback
  urgent
}

enum IssuePriority {
  low
  medium
  high
  critical
}

enum IssueStatus {
  open
  in_progress
  resolved
  closed
  duplicate
}

enum NotificationType {
  appointment
  assessment
  invoice
  system
  reminder
  message
}

model UserIssue {
  id          String        @id @default(uuid())
  title       String
  description String
  type        IssueType
  priority    IssuePriority @default(medium)
  status      IssueStatus   @default(open)

  // Reporter information
  reporterId String
  reporter   User   @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  // Clinic context (optional - for clinic-specific issues)
  clinicId String?
  clinic   Clinic? @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Additional context
  browserInfo    String? // Browser/device info
  url            String? // Page where issue occurred
  steps          String? // Steps to reproduce
  expectedResult String? // What should happen
  actualResult   String? // What actually happened
  attachments    String[] @default([]) // File URLs/paths

  // Admin response
  adminResponse String?
  adminId       String?
  admin         User?     @relation("AdminResponse", fields: [adminId], references: [id])
  resolvedAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reporterId])
  @@index([clinicId])
  @@index([status])
  @@index([type])
  @@index([priority])
}

enum SettingType {
  terms_and_conditions
  about_us
  privacy_policy
  faq
}

model Setting {
  id        String      @id @default(uuid())
  type      SettingType @unique
  content   String      @db.Text
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@index([type])
}

model FAQ {
  id        String   @id @default(uuid())
  question  String   @db.Text
  answer    String   @db.Text
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([order])
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  title     String
  message   String           @db.Text
  type      NotificationType
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}
